CMD_LEN = 3
NOT_INITIALIZED = 0
IS_INITIALIZED = 1
MIN_KEY_LENGTH = 15

progStart
    ;jsr showTitleScreen
    jmp readEvalPrintLoop


.COMMAND
!byte 5
!pet "cmd> "

.CMD_CHARS
!byte 52
!pet "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"

.CMD_BUFFER
!byte CMD_LEN
!byte 0,0,0

.EXIT_COMMAND
!byte 1
!pet "x"

.HELP_COMMAND
!byte 1
!pet "h"

.TEST_COMMAND
!byte 3
!pet "tst"

.DIR_COMMAND
!byte 3
!pet "dir"

.ENCRYPT_COMMAND
!byte 3
!pet "enc"

.DECRYPT_COMMAND
!byte 3
!pet "dec"

.DEV_COMMAND
!byte 3
!pet "dev"

.STATE_COMMAND
!byte 3
!pet "ste"

.INIT_COMMAND
!byte 3
!pet "ini"


.COMMAND_NOT_RECOGNIZED
!byte 22
!pet "command not recognized"

.ALPHA
!byte 76
!pet "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ.:-+#=() ยง$%&@"
!pet "abcdefghijklmnopqrstuvwxyz"


.DIGITS
!byte 10
!pet "0123456789"


.CMD_TABLE 
!byte <.HELP_COMMAND, >.HELP_COMMAND, <helpCommand, >helpCommand
!byte <.DIR_COMMAND, >.DIR_COMMAND, <dirCommand, >dirCommand
!byte <.DEV_COMMAND, >.DEV_COMMAND, <setDeviceNumberCommand, >setDeviceNumberCommand
!byte <.STATE_COMMAND, >.STATE_COMMAND, <stateCommand, >stateCommand
!byte <.INIT_COMMAND, >.INIT_COMMAND, <initCommand, >initCommand
!byte <.ENCRYPT_COMMAND, >.ENCRYPT_COMMAND, <encryptCommand, >encryptCommand
!byte <.DECRYPT_COMMAND, >.DECRYPT_COMMAND, <decryptCommand, >decryptCommand
!ifdef IS_TEST {
!byte <.TEST_COMMAND, >.TEST_COMMAND, <testCommand, >testCommand    
}
!byte 0,0,0,0 ; end marker


; --------------------------------------------------
; readEvalPrintLoop
; --------------------------------------------------
readEvalPrintLoop
.cmdLoop
    +printStr .COMMAND
    lda #CMD_LEN
    sta .CMD_BUFFER
    +inputStr .CMD_BUFFER, .CMD_CHARS
    jsr printCRLF
    lda .CMD_BUFFER
    beq .cmdLoop                                       ; do noting when user just pressed enter
    +strCmpAddr .EXIT_COMMAND, .CMD_BUFFER
    beq .done
    jsr processCommand
    jmp .cmdLoop
.done
    rts

.CMD_COUNTER
!byte 0
.CMD_VECTOR
!byte 0,0
.NO_COMMAND
!byte 0,0
; --------------------------------------------------
; processCommand
; --------------------------------------------------
processCommand
    +load16BitImmediate .CMD_BUFFER, TEMP_PTR2

    ldx #0
    stx .CMD_COUNTER
.testCommand
    ldx .CMD_COUNTER
    lda .CMD_TABLE,x
    sta TEMP_PTR
    inx
    lda .CMD_TABLE,x
    sta TEMP_PTR+1
    +cmp16Bit .NO_COMMAND, TEMP_PTR
    beq .notFound
    txa
    pha
    jsr strCmp
    bne .nextCommand
    pla
    tax
    inx
    lda .CMD_TABLE,X
    sta .CMD_VECTOR
    inx    
    lda .CMD_TABLE,X
    sta .CMD_VECTOR+1
    jmp (.CMD_VECTOR)
.nextCommand
    pla
    tax
    inx
    inx
    inx
    stx .CMD_COUNTER
    jmp .testCommand 

.notFound
    +printStr .COMMAND_NOT_RECOGNIZED
    jsr printCRLF
    rts


!ifdef IS_TEST {

.TEST_STR
!byte 5
!pet "test"
!byte $0d
testCommand
    jsr chachaTest
    ;jsr hexConvTest
    ;jsr chaChaDeriveTest
    ;jsr chaChaNonceTest
    ;jsr toStringTest
    rts

}

; --------------------------------------------------
; helpCommand
; --------------------------------------------------
helpCommand
    ldx #0
.commandLoop
    lda .CMD_TABLE,x
    sta TEMP_PTR
    inx
    lda .CMD_TABLE,x
    sta TEMP_PTR+1
    +cmp16Bit .NO_COMMAND, TEMP_PTR
    beq .allPrinted
    txa
    pha
    jsr printString
    jsr printCRLF
    pla
    tax
    inx
    inx
    inx
    jmp .commandLoop 

.allPrinted
    lda #88                                 ; add X command to help, as it is built in
    jsr CHAROUT
    jsr printCRLF
    rts



.CURRENT_POS_OFFSET
!byte 0
.MAX_POS_OFFSET
!byte 0
; --------------------------------------------------
; printDataOffset prints as many bytes as indicated by the X register 
; from the memory address to which TEMP_PTR points
; 
; INPUT:  X contains length, TEMP_PTR points to the data 
; OUTPUT: None
; --------------------------------------------------
printDataOffset
    stx .MAX_POS_OFFSET
    lda #0
    sta .CURRENT_POS_OFFSET
.printOffsetLoop
    ldy .CURRENT_POS_OFFSET
    cpy .MAX_POS_OFFSET
    beq .donePrintOffset
    lda (TEMP_PTR),y
    jsr CHAROUT 
    inc .CURRENT_POS_OFFSET
    jmp .printOffsetLoop
.donePrintOffset
    rts


!macro printOffset .addr, .length {
    +load16BitImmediate .addr, TEMP_PTR
    ldx #.length
    jsr printDataOffset
}

!macro printOffsetMem .addr, .length {
    +move16Bit .addr, TEMP_PTR
    ldx #.length
    jsr printDataOffset
}

.IO_ERROR_TXT
!byte 9
!pet "io error"
!byte $0d

.FILE_TYPE_SEQ_TXT
!byte 3
!pet "seq"
.FILE_TYPE_PRG_TXT
!byte 3
!pet "prg"
.FILE_TYPE_USR_TXT
!byte 3
!pet "usr"
.FILE_TYPE_REL_TXT
!byte 3
!pet "rel"
.FILE_TYPE_CBM_TXT
!byte 3
!pet "cbm"

.FILE_EXT_TAB
!byte <.FILE_TYPE_SEQ_TXT, >.FILE_TYPE_SEQ_TXT
!byte <.FILE_TYPE_PRG_TXT, >.FILE_TYPE_PRG_TXT
!byte <.FILE_TYPE_USR_TXT, >.FILE_TYPE_USR_TXT
!byte <.FILE_TYPE_REL_TXT, >.FILE_TYPE_REL_TXT
!byte <.FILE_TYPE_CBM_TXT, >.FILE_TYPE_CBM_TXT

!ifdef TARGET_VIC20 {
.SPACER
!byte 1
!tx " "
} else {
.SPACER
!byte 2
!tx "  "
}
.DIR_ENTRY_LEN
!byte 32, 0
.CURRENT_OFFSET
!byte 0, 0
.ENTRY_COUNTER
!byte 0
.ENTRY_ADDRESS
!byte 0,0
.FILE_TYPE
!byte 0
; --------------------------------------------------
; printDirectoryEntries prints all the directory entries currently
; stored at BLOCK_BUFFER
; --------------------------------------------------
printDirectoryEntries
    lda #0
    sta .ENTRY_COUNTER
    +load16BitImmediate 2, .CURRENT_OFFSET
.nextDirEntry
    lda .ENTRY_COUNTER
    cmp #8
    bne .continuePrintEntry
    jmp .donePrintEntries
.continuePrintEntry    
    +load16BitImmediate BLOCK_BUFFER, .ENTRY_ADDRESS
    +add16Bit .CURRENT_OFFSET, .ENTRY_ADDRESS
    ; determine file type    
    +move16Bit .ENTRY_ADDRESS, TEMP_PTR
    ldy #0
    lda (TEMP_PTR), y
    and #%00000111                                             ; file type is in the lower three bits
    beq .deletedEntry                                          ; file type = 0 => deleted entry
    tay
    dey
    sty .FILE_TYPE                                             ; store determined file type                                         
    ; print file name
    +printStr .SPACER
    +add16BitImmediate 3, .ENTRY_ADDRESS
    +printOffsetMem .ENTRY_ADDRESS, 16                         ; print file name
    lda #32
    jsr CHAROUT
    ; load file extension to print
    lda .FILE_TYPE
    asl
    tay
    lda .FILE_EXT_TAB,y
    sta TEMP_PTR
    iny
    lda .FILE_EXT_TAB,y
    sta TEMP_PTR+1
    jsr printString

    jsr printCRLF
.deletedEntry
    inc .ENTRY_COUNTER
    +add16Bit .DIR_ENTRY_LEN, .CURRENT_OFFSET
    jmp .nextDirEntry
.donePrintEntries
    rts

.TXT_FREE_BLOCKS
!byte 14
!pet "free blocks: $"
.NEXT_TRACK
!byte 0
.NEXT_SECTOR
!byte 0
.FREE_BLOCKS
!byte 0, 0
.FREE_BLOCKS_IN_TRACK
!byte 0, 0
; --------------------------------------------------
; dirCommand
; --------------------------------------------------
dirCommand
    +load16BitImmediate 0, .FREE_BLOCKS
    +readBlockImmediate 18,0
    cmp #DISK_IO_OK
    beq .continueDirCommand
    jmp .printDiskError
.continueDirCommand
    ; print disk name
    +printOffset BLOCK_BUFFER+144, 16
    jsr printCRLF

    ; calculate number of free blocks on disk
    ldy #4
.addNextBlocks
    lda BLOCK_BUFFER, y
    sta .FREE_BLOCKS_IN_TRACK
    +add16Bit .FREE_BLOCKS_IN_TRACK, .FREE_BLOCKS
    iny
    iny
    iny
    iny
    cpy #144
    bne .addNextBlocks

    ldy #18*4
    lda BLOCK_BUFFER, y
    sta .FREE_BLOCKS_IN_TRACK
    +sub16Bit .FREE_BLOCKS_IN_TRACK, .FREE_BLOCKS             ; subtract the free blocks of track 18

.loopDirectoryBlocks
    ; test for last block
    +cmp16BitImmediate $FF00, BLOCK_BUFFER
    beq .dirFinish

    ; read next block of directory
    +readBlock BLOCK_BUFFER, BLOCK_BUFFER+1
    cmp #DISK_IO_OK
    bne .printDiskError

    ; print entries contained in currently loaded sector
    jsr printDirectoryEntries
    jmp .loopDirectoryBlocks

.dirFinish
    ; print number of free blocks
    +printStr .TXT_FREE_BLOCKS
    lda .FREE_BLOCKS+1
    jsr printByte
    lda .FREE_BLOCKS
    jsr printByteCRLF

    rts
.printDiskError
    +printStr .IO_ERROR_TXT
    +printStr ERR_BYTE_COUNTER
    jsr printCRLF
    rts


.TXT_INITIALIZED
!byte 13
!pet "initialized: "

.TXT_YES
!byte 3
!pet "yes"

.TXT_NO
!byte 2
!pet "no"


; --------------------------------------------------
; stateCommand
; --------------------------------------------------
stateCommand
    +printStr .TXT_DEVICE_NUMBER
    lda DEVICE_NUM
    jsr printByteCRLF

    +printStr .TXT_INITIALIZED
    lda ALREADY_INITIALIZED
    cmp #IS_INITIALIZED
    beq .printInitialized
    +printStr .TXT_NO
    jmp .printCRLF
.printInitialized
    +printStr .TXT_YES
    jsr printCRLF
    +printStr KEY_ID_STR
    lda #36
    jsr CHAROUT
    +printByteVector KEY_ID
.printCRLF
    jsr printCRLF

    rts


.ERR_OUT_OF_RANGE
!byte 18
!pet "value out of range"
.ERR_NO_CONVERT
!byte 16
!pet "can not convert"
!byte $0d


.TXT_DEVICE_NUMBER_INPUT
!byte 15
!pet "device number: "
.TXT_DEVICE_NUMBER
!byte 16
!pet "device number: $"
.DEV_NUM_BUFFER
!byte 2
!byte 0,0
.NEW_DEV_NUM
!byte 0,0
; --------------------------------------------------
; setDeviceNumberCommand
; --------------------------------------------------
setDeviceNumberCommand
    ; set size of input buffer
    lda #2
    sta .DEV_NUM_BUFFER
    ; read new device number and store it in .NEW_DEV_NUM
    +printStr .TXT_DEVICE_NUMBER_INPUT
    +inputStr .DEV_NUM_BUFFER, .DIGITS
    +atoi .DEV_NUM_BUFFER, .NEW_DEV_NUM
    bne .convErrDevNum
    lda .NEW_DEV_NUM                             ; allowed device numbers are 8-11
    cmp #12                                      
    bcs .errOutOfRangeDevNum                     ; device number is >= 12 => Error out of range
    cmp #8                      
    bcc .errOutOfRangeDevNum                     ; device number < 8 => Error out of range
    sta DEVICE_NUM                               ; store new device number
    jsr printCRLF
    rts

.convErrDevNum
    jsr printCRLF
    +printStr .ERR_NO_CONVERT
    jsr printCRLF
    rts
.errOutOfRangeDevNum
    jsr printCRLF
    +printStr .ERR_OUT_OF_RANGE
    jsr printCRLF
    rts



PET_HEX_CHARS
!byte 16
!pet "0123456789abcdef"

PET_KEY_CHARS
!byte 64
!pet "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ+/"

KEY_ID_STR
!byte 8
!pet "key id: "

NONCE_PREFIX_STR
!byte 14
!pet "nonce prefix: "

KEY_STR
!byte 5
!pet "key: "

CHECK_VALUE_STR
!byte 13
!pet "check value: "

.ERR_NOT_LONG_ENOUGH
!byte 17
!pet "not enough chars"
!byte $0d

.ERR_AT_LEAST_15
!byte 29
!pet "length has to be at least 15"
!byte $0d

.ERR_CHECK_VAL_INCORRECT
!byte 20
!pet "check val incorrect"
!byte $0d

KEY_ID_NUM_CHARS = 4
NONCE_PREFIX_NUM_CHARS = 4
CHECK_VAL_NUM_CHARS = 6
KEY_SEED_LEN = 32

ALREADY_INITIALIZED 
!byte NOT_INITIALIZED

KEY_IN_BUFFER
!byte KEY_SEED_LEN
!skip KEY_SEED_LEN

CHECK_VALUE_REFERENCE
!byte CHECK_VAL_NUM_CHARS/2
!skip CHECK_VAL_NUM_CHARS/2

CHECK_VALUE
!byte CHECK_VAL_NUM_CHARS/2
!skip CHECK_VAL_NUM_CHARS/2

KEY_ID
!byte KEY_ID_NUM_CHARS/2
!skip KEY_ID_NUM_CHARS/2

NONCE_PREFIX
!byte NONCE_PREFIX_NUM_CHARS/2
!skip NONCE_PREFIX_NUM_CHARS/2

MESSAGE_NUMBER
!byte 2
!byte 0,0

DAY_KEY
!byte 32
!skip 32

HEX_CONV_BUFFER_IN
!byte 6
!byte 0,0,0,0,0,0

initCommand
    lda #NOT_INITIALIZED
    sta ALREADY_INITIALIZED

    lda #KEY_ID_NUM_CHARS/2                                      
    sta KEY_ID                                                   ; set length of KEY_ID buffer
    lda #NONCE_PREFIX_NUM_CHARS/2
    sta NONCE_PREFIX                                             ; set length of NONCE_PREFIX buffer
    lda #CHECK_VAL_NUM_CHARS/2
    sta CHECK_VALUE_REFERENCE                                    ; set length of check value reference

    ; enter key ID
    lda #KEY_ID_NUM_CHARS                                        ; set maximum input length
    sta HEX_CONV_BUFFER_IN
    +printStr KEY_ID_STR
    +inputStr HEX_CONV_BUFFER_IN, PET_HEX_CHARS                  ; read input
    jsr printCRLF
    lda HEX_CONV_BUFFER_IN
    cmp #KEY_ID_NUM_CHARS                                        ; check that the correct number of chars has been entered
    beq .doConvert
    jmp .notLongEnough
.doConvert
    +xtoi HEX_CONV_BUFFER_IN, KEY_ID                             ; convert hex string to byte vector
    beq .goOn
    jmp .convErrIni
.goOn

    ; enter nonce prefix
    lda #NONCE_PREFIX_NUM_CHARS                                 ; set maximum input length
    sta HEX_CONV_BUFFER_IN
    +printStr NONCE_PREFIX_STR
    +inputStr HEX_CONV_BUFFER_IN, PET_HEX_CHARS                 ; read input
    jsr printCRLF
    lda HEX_CONV_BUFFER_IN
    cmp #NONCE_PREFIX_NUM_CHARS                                 ; check that the correct number of chars has been entered
    beq .hexConvNonce
    jmp .notLongEnough
.hexConvNonce
    +xtoi HEX_CONV_BUFFER_IN, NONCE_PREFIX                      ; convert hex string to byte vector
    beq .contReadKey
    jmp .convErrIni

.contReadKey
    ; enter key seed
    lda #32                                                     ; set maximum input length
    sta KEY_IN_BUFFER

    +printStr KEY_STR
    +inputStr KEY_IN_BUFFER, PET_KEY_CHARS                      ; read input
    jsr printCRLF

    lda KEY_IN_BUFFER
    cmp #MIN_KEY_LENGTH
    bcs .perfDeriveKey                                          ; check if minimal length is reached (15 B64 chars => 90 bits sec.)
    jmp .errAtLeast15

.perfDeriveKey
    +chaChaDerive KEY_IN_BUFFER, KEY_ID, DAY_KEY, CHECK_VALUE   ; perform key derivation

!ifdef IS_TEST {
    +printByteVector CHECK_VALUE
    jsr printCRLF    
}
    ; xor nonce prefix to check value
    ldy #1
    lda CHECK_VALUE, y
    eor NONCE_PREFIX, Y
    sta CHECK_VALUE, y
    iny
    lda CHECK_VALUE, y
    eor NONCE_PREFIX, Y
    sta CHECK_VALUE, y

!ifdef IS_TEST {
    +printByteVector CHECK_VALUE
    jsr printCRLF    
}
    ; enter check value
    lda #CHECK_VAL_NUM_CHARS                                    ; set maximum input length
    sta HEX_CONV_BUFFER_IN
    +printStr CHECK_VALUE_STR
    +inputStr HEX_CONV_BUFFER_IN, PET_HEX_CHARS                 ; read input
    jsr printCRLF
    lda HEX_CONV_BUFFER_IN
    cmp #CHECK_VAL_NUM_CHARS                                    ; check that the correct number of chars has been entered
    beq .hexConvCheckVal
    jmp .notLongEnough
.hexConvCheckVal
    +xtoi HEX_CONV_BUFFER_IN, CHECK_VALUE_REFERENCE             ; convert hex string to byte vector
    beq .validateCheckValue
    jmp .convErrIni

.validateCheckValue
    +strCmpAddr CHECK_VALUE, CHECK_VALUE_REFERENCE
    bne .notValidated

    lda #IS_INITIALIZED
    sta ALREADY_INITIALIZED

    rts
    ; error handling
.convErrIni
    +printStr .ERR_NO_CONVERT
    rts
.notLongEnough
    +printStr .ERR_NOT_LONG_ENOUGH
    rts
.errAtLeast15
    +printStr .ERR_AT_LEAST_15
    rts
.notValidated
    +printStr .ERR_CHECK_VAL_INCORRECT
    rts


TXT_FILE_NAME
!byte 11
!pet "file name: "

.TXT_NOT_INITIALIZED
!byte 16
!pet "not initialized"
!byte $0d

TXT_MSG_NUMBER
!byte 9
!pet "msg nr.: "

DECIMAL_CHARS
!byte 10
!pet "0123456789"

MSG_NUM_CHAR_LEN = 3

MESSAGE_NUMBER_BUFFER_IN
!byte MSG_NUM_CHAR_LEN
!skip MSG_NUM_CHAR_LEN

FILE_NAME_SIZE = 16

INPUT_FILE_NAME
!byte FILE_NAME_SIZE
!skip FILE_NAME_SIZE


enterFileName 
    +printStr TXT_FILE_NAME
    lda #FILE_NAME_SIZE
    sta INPUT_FILE_NAME
    +inputStr INPUT_FILE_NAME, .ALPHA
    jsr printCRLF

    rts


encryptCommand
    lda ALREADY_INITIALIZED
    cmp #NOT_INITIALIZED
    beq .errNotInitialized
    jsr enterFileName

    lda #MSG_NUM_CHAR_LEN
    sta MESSAGE_NUMBER_BUFFER_IN
    +printStr TXT_MSG_NUMBER
    +inputStr MESSAGE_NUMBER_BUFFER_IN, DECIMAL_CHARS
    jsr printCRLF
    +atoi MESSAGE_NUMBER_BUFFER_IN, MESSAGE_NUMBER+1
    bne .errNotConvert

    ; ToDo implement encryption
    +printByteVector MESSAGE_NUMBER
    jsr printCRLF

    rts
.errNotInitialized
    +printStr .TXT_NOT_INITIALIZED
    rts
.errNotConvert
    +printStr .ERR_NO_CONVERT
    rts


decryptCommand
    lda ALREADY_INITIALIZED
    cmp #NOT_INITIALIZED
    beq .errNotInitializedDec
    jsr enterFileName

    ; ToDo: Implement decryption

    rts
.errNotInitializedDec
    +printStr .TXT_NOT_INITIALIZED
    rts


!ifdef IS_TEST {


TEST_STR
!byte 0
!byte 0,0,0,0
.DUMMY
!pet "897b"

toStringTest
    +bytesToString .DUMMY, 4, TEST_STR
    +printStr TEST_STR
    jsr printCRLF

    rts

.convErrHex
    +printStr .ERR_NO_CONVERT
    jsr printCRLF
    rts

}